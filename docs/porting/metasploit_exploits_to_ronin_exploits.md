---
layout: page
title: Porting Metasploit Exploits to Ronin Exploits
---

# Porting Metasploit Exploits modules to Ronin Exploits

This guide explains how to convert a Metasploit exploit into a
[Ronin exploit][Ronin::Exploits::Exploit].

## Table of Contents

* [Class Definition](#class-definition)
* [Included Modules](#included-modules)
* [Metadata](#metadata)
* [Targets](#targets)
* [Options vs. Params](#options-vs-params)
* [`check` vs. test methods](#check-vs-test-methods)
* [`exploit` vs. `validate`/`build`/`launch`/`cleanup` methods](#exploit-vs-validatebuildlaunchcleanup-methods)
* [`cleanup` method](#cleanup-method)
* [Printing](#printing)
* [Random Text](#random-text)
* [Packing](#packing)
* [Remote TCP](#remote-tcp)
* [Remote UDP](#remote-udp)
* [HTTP](#http)
* [Loot](#loot)

## Class Definition

### Metasploit

Every Metasploit exploit class is named `MetasploitModule` and inherits from
either `Msf::Exploit::Remote`, `Msf::Exploit::Local`, or `Msf::Exploit`.

```ruby
class MetasploitModule < Msf::Exploit::Remote

  # ...

end
```

### Ronin

[Ronin exploits][Ronin::Exploits::Exploit] classes must be:

1. Require any classes or modules used.
2. Defined in the `Ronin::Exploits` namespace.
3. Have a unique `CamelCase` name similar to the file name.
4. Inherit from [Ronin::Exploits::Exploit] or one of it's sub-classes.
5. Call `register` with the same name as it's file name.

```ruby
# exploits/my_exploit.rb
require 'ronin/exploits/exploit'

module Ronin
  module Exploits
    class MyExploit < Exploit

      register 'my_exploit'

      # ...

    end
  end
end
```

**Note:** the `ronin-exploits new` command can generate a skeleton exploit
file, complete with included modules and metadata, which can save some typing.

## Included Modules

Both Metasploit exploits and Ronin exploit classes will include modules to add
additional functionality.

### Metasploit

```ruby
class MetasploitModule < Msf::Exploit::Remote

  include Msf::Exploit::Remote::Tcp
  # ...

end
```

### Ronin

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/remote_tcp'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::RemoteTCP

      # ...

    end
  end
end
```

**Note:** additional modules must be explicitly required in order to be used.
However, some other exploit classes will have certain modules already
included by default, such as how [Ronin::Exploits::SEHOverflow] includes
[Ronin::Exploits::Mixins::SEH].

[Ronin::Exploits::SEHOverflow]: /docs/ronin-exploits/Ronin/Exploits/SEHOverflow.html

**Note:** the `ronin-exploits new` command can generate a skeleton exploit
file, complete with included modules and metadata, which can save some typing.

### Cheat Sheet

Metasploit                         | Ronin
-----------------------------------|-------------------------------------------
`Msf::Exploit::Remote::Tcp`        | [Mixins::RemoteTCP][Ronin::Exploits::Mixins::RemoteTCP]
`Msf::Exploit::Remote::Udp`        | [Mixins::RemoteUDP][Ronin::Exploits::Mixins::RemoteUDP]
`Msf::Exploit::Remote::HttpClient` | [Mixins::HTTP][Ronin::Exploits::Mixins::HTTP]
`Msf::Exploit::Seh`                | [Mixins::SEH][Ronin::Exploits::Mixins::SEH]
`Msf::Exploit::FormatString`       | [Mixins::FormatString][Ronin::Exploits::Mixins::FormatString]

[Ronin::Exploits::Mixins::RemoteTCP]: /docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html
[Ronin::Exploits::Mixins::RemoteUDP]: /docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html
[Ronin::Exploits::Mixins::HTTP]: /docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html
[Ronin::Exploits::Mixins::FormatString]: /docs/ronin-exploits/Ronin/Exploits/Mixins/FormatString.html
[Ronin::Exploits::Mixins::SEH]: /docs/ronin-exploits/Ronin/Exploits/Mixins/SEH.html

## Metadata

### Metasploit

Metasploit exploits define their metadata in the `initialize` method by
passing a large Hash of Strings:

```ruby
class MetasploitModule < Msf::Exploit::Remote

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'DD-WRT HTTP Daemon Arbitrary Command Execution',
      'Description'    => %q{
          This module abuses a metacharacter injection vulnerability in the
        HTTP management server of wireless gateways running DD-WRT. This flaw
        allows an unauthenticated attacker to execute arbitrary commands as
        the root user account.
      },
      'Author'         => [ 'gat3way', 'hdm' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2009-2765' ],
          [ 'OSVDB', '55990' ],
          [ 'BID', '35742' ],
          [ 'EDB', '9209' ]
        ],
      # ...
      'DisclosureDate' => '2009-07-20'
      ))
  end

end
```

### Ronin

Ronin exploits and payloads define their metadata in the class body by calling
class methods:

* [register](/docs/ronin-exploits/Ronin/Exploits/Exploit.html#register-class_method)
* [summary](/docs/ronin-core/Ronin/Core/Metadata/Summary/ClassMethods.html#summary-instance_method)
* [description](/docs/ronin-core/Ronin/Core/Metadata/Description/ClassMethods.html#description-instance_method)
* [author](/docs/ronin-core/Ronin/Core/Metadata/Authors/ClassMethods.html#author-instance_method)
* [disclosure_date](/docs/ronin-exploits/Ronin/Exploits/Exploit.html#disclosure_date-class_method)
* [release_date](/docs/ronin-exploits/Ronin/Exploits/Exploit.html#release_date-class_method)
* [advisory](/docs/ronin-exploits/Ronin/Exploits/Exploit.html#advisory-class_method)
* [software](/docs/ronin-exploits/Ronin/Exploits/Exploit.html#software-class_method)
* [software_version](/docs/ronin-exploits/Ronin/Exploits/Exploit.html#software_versions-class_method)
* [references](/docs/ronin-core/Ronin/Core/Metadata/References/ClassMethods.html#references-instance_method)

```ruby
require 'ronin/exploits/exploit'

module Ronin
  module Exploits
    class MyExploit < Exploit

      register 'my_exploit'

      summary 'A single sentence summary of the exploit'
      description <<~EOS
        A longer multi-line or multi-paragraph description of the exploit.
        Bla bla bla bla.
      EOS

      author 'Author1'
      author 'Author2', website:  'https://example.com',
                        email:    'author1@example2.com',
                        github:   'author2',
                        mastodon: 'https://example.com/@author2',
                        twitter:  '@author2',
                        discord:  '...'

      disclosure_date 'YYY-MM-DD'
      release_date 'YYYY-MM-DD'

      advisory 'CVE-YYYY-NNNN'
      advisory 'GHSA-XXXXXX'

      software 'TestHTTP'
      software_versions '1.0.0'..'1.5.4'

      references [
        'https://example.com/url1',
        'https://example.com/url2',
        # ...
      ]

      # ...

    end
  end
end
```

Additional [metadata modules][Ronin::Exploits::Metadata] can be
included to define additional metadata, such as
[Metadata::Arch][Ronin::Exploits::Metadata::Arch] or
[Metadata::OS][Ronin::Exploits::Metadata::OS].
If the exploit class inherits from the
[MemoryCorruption][Ronin::Exploits::MemoryCorruption] class, or one of it's
sub-class, then those modules are already included by default.

[Ronin::Exploits::Metadata]: /docs/ronin-exploits/Ronin/Exploits/Metadata.html
[Ronin::Exploits::Metadata::Arch]: /docs/ronin-exploits/Ronin/Exploits/Metadata/Arch.html
[Ronin::Exploits::Metadata::OS]: /docs/ronin-exploits/Ronin/Exploits/Metadata/OS.html
[Ronin::Exploits::MemoryCorruption]: /docs/ronin-exploits/Ronin/Exploits/MemoryCorruption.html

```ruby
require 'ronin/exploits/stack_overflow'

module Ronin
  module Exploits
    class MyExploit < StackOverflow

      # ...

      arch :arm
      os :linux

      # ...

    end
  end
end
```

See the [arch], [os], and [os_version] method documentation for further details.

[arch]: /docs/ronin-exploits/Ronin/Exploits/Metadata/Arch/ClassMethods.html#arch-instance_method
[os]: /docs/ronin-exploits/Ronin/Exploits/Metadata/OS/ClassMethods.html#os-instance_method
[os_version]: /docs/ronin-exploits/Ronin/Exploits/Metadata/OS/ClassMethods.html#os_version-instance_method

**Note:** the `ronin-exploits new` command can generate a skeleton exploit
file, complete with included modules and metadata, which can save some typing.

### Cheat Sheet

<table>
  <thead>
    <tr>
      <td width="50%">Metasploit</td>
      <td width="50%">Ronin</td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <pre>Name' => '...',</pre>
      </td>
      <td>
        <pre>summary '...'</pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre>'Description'    => %q{
   ...
},</pre>
      </td>
      <td>
        <pre>description &lt;&lt;~DESC
  ...
DESC</pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre>'License'        => MSF_LICENSE,</pre>
      </td>
      <td>
        N/A
      </td>
    </tr>
    <tr>
      <td>
        <pre>'Author'         => [
  'John Doe', # discoverer
  ...
],</pre>
      </td>
      <td>
        <pre>author 'John Doe'
...</pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre>'References'     =>
  [
    [ 'CVE', 'YYYY-NNNN' ],
    [ 'GHSA', 'XXXXXX' ],
    [ 'URL', 'https://example.com/...' ],
  ],</pre>
      </td>
      <td>
        <pre>
advisory 'CVE-YYYY-NNNN'
advisory 'GHSA-XXXXXX'

references [
  'https://example.com/...',
  # ...
]</pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre>'Platform'       => 'Linux',</pre>
      </td>
      <td>
        <pre>include Metadata::OS
# ...

os :linux</pre>
      </td>
    </tr>
  </tbody>
</table>

## Targets

### Metasploit

Metasploit exploits define additional platform targeting information as an
Array of Arrays in the metadata section.

```ruby
class MetasploitModule < Msf::Exploit::Remote

  # ...

  def initialize(info = {})
    super(update_info(info,
      # ...
      'Targets'        =>
        [
          # npFoxitReaderPlugin.dll version 2.2.1.530
          [ 'Automatic', {} ],
          [ 'Windows 7 SP1 / Firefox 18 / Foxit Reader 5.4.4.11281',
            {
              'Offset'          => 272,
              'Ret'             => 0x1000c57d, # pop # ret # from npFoxitReaderPlugin
              'WritableAddress' => 0x10045c10, # from npFoxitReaderPlugin
              :rop => :win7_rop_chain
            }
          ]
        ],
      'DefaultTarget'  => 0,
      # ...
    ))

    # ...
  end

end
```

### Ronin

[Ronin exploits][Ronin::Exploits::Exploit] may define additional platform
targeting by including the
[Mixins::HasTargets][Ronin::Exploits::Mixins::HasTargets] module.
The [Mixins::HasTargets][Ronin::Exploits::Mixins::HasTargets] module adds a
`target` class method for defining platform/software specific target
information.

[Ronin::Exploits::Mixins::HasTargets]: /docs/ronin-exploits/Ronin/Exploits/Mixins/HasTargets.html

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/has_targets'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::HasTargets

      # ...

      target os: :windows, os_version: '7 SP1', software: 'Foxit Reader', software_version: '5.4.4.11281' do |target|
        target.offset           = 272
        target.ret              = 0x1000c57d, # pop # ret # from npFoxitReaderPlugin
        target.writable_address = 0x10045c10, # from npFoxitReaderPlugin
        target.rop              = :win7_rop_chain
      end

      # ...

    end
  end
end
```

**Note:** [Mixins::HasTargets][Ronin::Exploits::Mixins::HasTargets] does not
support the concept of a default target. If an exploit defines targets,
a target must be selected.

## Options vs. Params

### Metasploit

Metasploit exploits defines options using the `register_options` within the
`initialize` method. The `register_options` method accepts an Array of one or
more options. The options are initialized using `OptString`, `OptBool`, etc,
option classes. The first argument is the option name in all uppercase.
The second argument is the option description. The first argument is the
optional default value for the option.

```ruby
class MetasploitModule < Msf::Exploit::Remote

  def initialize(info = {})
    # ...

    register_options([
      OptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf' ])
    ])
  end

end
```

### Ronin

[Ronin exploits][Ronin::Exploits::Exploit] defines options using the [param]
method which can be called multiple times. The first argument is the
param name, in lowercase or `snake_case`. The second argument is the
param [type class][Ronin::Core::Params::Types]. Additional keyword arguments
may define whether the param is required, it's default value, and it's
description.

[param]: /docs/ronin-core/Ronin/Core/Params/Mixin/ClassMethods.html#param-instance_method
[Ronin::Core::Params::Types]: /docs/ronin-core/Ronin/Core/Params/Types.html

```ruby
require 'ronin/exploits/exploit'

module Ronin
  module Exploits
    class MyExploit < Exploit

      # ...

      param :filename, String, required: true,
                               default:  'msf.pdf',
                               desc:     'The file name'

      # ...

    end
  end
end
```

**Note:** [ronin-exploits] provides [modules][Ronin::Exploits::Params] for
certain common params which can be included into your exploit class. These
params modules are also automatically included by certain
[Mixin modules][Ronin::Exploits::Mixins], such as
[Mixins::RemoteTCP][Ronin::Exploits::Mixins::RemoteTCP],
[Mixins::RemoteUDP][Ronin::Exploits::Mixins::RemoteUDP], or
[Mixins::FileBuilder][Ronin::Exploits::Mixins::FileBuilder].

[Ronin::Exploits::Params]: /docs/ronin-exploits/Ronin/Exploits/Params.html
[Ronin::Exploits::Mixins]: /docs/ronin-exploits/Ronin/Exploits/Mixins.html
[Ronin::Exploits::Mixins::RemoteTCP]: /docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html
[Ronin::Exploits::Mixins::RemoteUDP]: /docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html
[Ronin::Exploits::Mixins::FileBuilder]: /docs/ronin-exploits/Ronin/Exploits/Mixins/FileBuilder.html

### Cheat Sheet

Metasploit                        | Ronin
----------------------------------|--------------------------------------------
`OptString.new('FOO', ...)`       | `param :foo, String, ...`
`OptInt.new('FOO', ...)`          | `param :foo, Integer, ...`
`OptBool.new('FOO', ...)`         | `param :foo, Boolean, ...`
`OptEnum.new('FOO', [true, '...', ['value1', 'value2', ...])` | `param :foo, Enum[:value1, :value2, ...]`
`Opt::RHOST()`                    | `include Params::Host`
`Opt::RPORT()`                    | `include Params::Port`
`Opt::RPORT(443)`                 | `include Params::Port` and `default_port 443`
`Opt::LHOST()`                    | `include Params::BindHost`
????                              | `include Params::BindPort`
`OptString.new('TARGETURI', ...)` | `include Params::BaseURL`
`OptString.new('FILENAME', [true, '...', 'foo.pdf'])`  | `include Params::Filename` and `default_filename 'foo.pdf'`

## `check` vs. `test` methods

### Metasploit

A Metasploit exploit may define a `check` method which tests whether the
remote host is vulnerable to the exploit. These `check` methods will return
a `Exploit::CheckCode::Safe`, `Exploit::CheckCode::Vulnerable`, `Exploit::CheckCode::Detected`, `Exploit::CheckCode::Appears`, or `Exploit::CheckCode::Unknown` value to
indicate the status of the remote host.

```ruby
class MetasploitModule < Msf::Exploit::Remote

  # ...

  def check
    uri = '/tws/getStatus'

    res = send_request_cgi({
      'method' => 'POST',
      'uri'    => uri,
      'vars_post' => {
        'transaction_id' => rand(0x100000000),
        'oauth_token'    => 'invalid'
    }})

    unless res && res.code == 200 && res.body.to_s =~ /"result_msg":"MD5 token is invalid"/
      return Exploit::CheckCode::Safe
    end

    res = send_request_cgi({
      'method' => 'POST',
      'uri'    => uri,
      'vars_post' => {
        'transaction_id' => rand(0x100000000),
        'oauth_token'    => "';echo '"
    }})

    unless res && res.code == 200 && res.body.to_s =~ /"result_msg":"Success","transaction_id":"/
      return Exploit::CheckCode::Safe
    end

    Msf::Exploit::CheckCode::Vulnerable
  end

  # ...

end
```

### Ronin

A [Ronin exploit][Ronin::Exploits::Exploit] may define a `test` method which
tests whether the remote host is indeed vulnerable to the exploit. Unlike
Metasploit's `check` method, the `test` method may only return
[Vulnerable('message here')][Ronin::Exploits::Exploit::Vulnerable],
[NotVulnerable('message here')][Ronin::Exploits::Exploit::NotVulnerable], or 
[Unknown('message here')][Ronin::Exploits::Exploit::Unknown].

[Ronin::Exploits::Exploit::Vulnerable]: /docs/ronin-exploits/Ronin/Exploits/Exploit.html#Vulnerable-instance_method
[Ronin::Exploits::Exploit::NotVulnerable]: /docs/ronin-exploits/Ronin/Exploits/Exploit.html#NotVulnerable-instance_method
[Ronin::Exploits::Exploit::Unknown]: /docs/ronin-exploits/Ronin/Exploits/Exploit.html#Unknown-instance_method

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/http'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::HTTP

      # ...

      def test
        case http.get_body('/')
        when /Powered by Foo 4\.19\./
          Vulnerable('host is vulnerable')
        when /Powered by Foo 4\.2[0-9]\./
          NotVulnerable('host is patched')
        else
          Unknown('cannot determine whether the host is vulnerable or not')
        end
      end

      # ...

    end
  end
end
```

### Cheat Sheet

Metasplioit                      | Ronin
---------------------------------|----------------------------------------------
`Exploit::CheckCode::Safe`       | `NotVulnerable("host is not vulnerable")`
`Exploit::CheckCode::Vulnerable` | `Vulnerable("host is vulnerable")`
`Exploit::CheckCode::Detected`   | `Unknown("the service is running but could not be validated")`
`Exploit::CheckCode::Appears`    | `Unknown("the host appears to be vulnerable")`
`Exploit::CheckCode::Unknown`    | `Unknown("...")`

## `exploit` vs. `validate`/`build`/`launch`/`cleanup` methods

### Metasploit

Metasploit exploits define the exploit's logic in one giant `exploit` method:

```ruby
class MetasploitModule < Msf::Exploit::Remote

  def exploit
    connect_udp

    nops = make_nops(50)
    lead = rand_text_alphanumeric(target['Offset'] - payload.encoded.length - nops.length)
    near = "\xe9\x80\xfd\xff\xff"    #jump back 640 bytes to the nop sled
    nseh = "\xeb\xf9" + make_nops(2) #jump back 7 bytes to the long jump

    evil = lead + nops + payload.encoded + near + nseh + [target.ret].pack('V')
    mode = "netascii"

    #Send the WRQ packet (header "\x00\x02")
    sploit = "\x00\x02" + evil + "\0" + mode +"\0"

    udp_sock.put(sploit)

    handler
    disconnect_udp
  end

end
```

### Ronin

While the [Ronin::Exploits::Exploit] class do provide an
[exploit][Ronin::Exploits::Exploit#exploit] method as an entry-point method
for running the exploit, [Ronin exploits][Ronin::Exploits::Exploit]
define their exploit logic in four main methods:

[Ronin::Exploits::Exploit#exploit]: /docs/ronin-exploits/Ronin/Exploits/Exploit.html#exploit-instance_method

1. `validate` - Perform any additional validations before building the exploit.
2. `build` - Builds any exploit buffers, files, or other data that will be used.
3. `launch` - Sends the exploit to the host or service.
4. `cleanup` - Perform any extra cleanup tasks after the user is done using the
   exploit.

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/has_targets'
require 'ronin/exploits/mixins/has_payload'
require 'ronin/exploits/mixins/text'
require 'ronin/exploits/mixins/nops'
require 'ronin/exploits/mixins/remote_udp'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::HasTargets
      include Mixins::HasPayload
      include Mixins::Text
      include Mixins::NOPS
      include Mixins::RemoteUDP

      def build
        nopsled = nops(50)

        lead = random_alpha_numeric(target.offset - payload.length - nopsled.length)
        near = "\xe9\x80\xfd\xff\xff" # jump back 640 bytes to the nop sled
        nseh = "\xeb\xf9" + nops(2)   # jump back 7 bytes to the long jump

        evil = lead + nopsled + payload + near + nseh + target.ret.pack(:uint32_le)

        # send the WRQ packet (header "\x00\x02")
        mode    = "netascii"
        @buffer = "\x00\x02" + evil + "\0" + mode +"\0"
      end

      def launch
        # connect to the remote service, send the data, return the open socket
        @socket = udp_connect_and_send(@buffer)
      end

      def cleanup
        # close the open socket
        @socket.close
      end

    end
  end
end
```

## `cleanup` method

Both Metasploit and Ronin define a `cleanup` method for additional logic to
cleanup after the exploit.

## Printing

### Metasploit

Metasploit provides a set of methods for printing status messages from an
exploit:

```ruby
    print_status "Running the Javascript shell..."
    # ...

    print_warning("Unable to retrieve token")
    # ...

    print_error('Connection failed.')
    # ...
```

### Ronin

Ronin also provides a similar set of methods for printing status messages
from an exploit:

* [print_debug](/docs/ronin-support/Ronin/Support/CLI/Printing.html#print_debug-instance_method)
* [print_error](/docs/ronin-support/Ronin/Support/CLI/Printing.html#print_error-instance_method)
* [print_info](/docs/ronin-support/Ronin/Support/CLI/Printing.html#print_info-instance_method) /`print_status`
* [print_negative](/docs/ronin-support/Ronin/Support/CLI/Printing.html#print_negative-instance_method) / `print_failure` / `print_bad`
* [print_positive](/docs/ronin-support/Ronin/Support/CLI/Printing.html#print_positive-instance_method) / `print_success` / `print_good`
* [print_warning](/docs/ronin-support/Ronin/Support/CLI/Printing.html#print_warning-instance_method)

```ruby
    print_status "Sending request to /path ..."
    response = http_get('/path')

    if response.code == '200'
      if response.body.include?('Success')
        print_success "response indicates success! Proceeding ..."
      else
        print_failure "request failed! Trying again ..."
        print_debug response.body
      end
    else
      print_error "Did not receive a 200 response: #{response.code}"
    end
```

### Cheat Sheet

<table>
  <thead>
    <tr>
      <td width="50%">Metasploit</td>
      <td width="50%">Ronin</td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <code>print_status("Message here")</code><br/>
        <code>vprint_status("Message here")</code>
      </td>
      <td>
        <code>print_info "Message here"</code> /<br/>
        <code>print_status "Message here"</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>print_good("Message here")</code><br/>
        <code>vprint_good("Message here")</code>
      </td>
      <td>
        <code>print_good "Message here"</code> /<br/>
        <code>print_success "Message here"</code> /<br/>
        <code>print_positive "Message here"</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>print_bad("Message here")</code><br/>
        <code>vprint_bad("Message here")</code>
      </td>
      <td>
        <code>print_bad "Message here"</code> /<br/>
        <code>print_failure "Message here"</code> /<br/>
        <code>print_negative "Message here"</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>print_warning("Message here")</code><br/>
        <code>vprint_warning("Message here")</code>
      </td>
      <td>
        <code>print_warning "Message here"</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>print_error("Message here")</code><br/>
        <code>print_bad("Message here")</code><br/>
        <code>vprint_error("Message here")</code><br/>
        <code>vprint_bad("Message here")</code>
      </td>
      <td>
        <code>print_error "Message here"</code>
      </td>
    </tr>
  </tbody>
</table>

## Random Text

### Metasploit

Metasploit exploits provide a series of methods for generating random text,
such as `rand_text_alpha` or `rand_text_alphanumeric`.

* [random_alpha](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_alpha-instance_method)
* [random_alpha_numeric](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_alpha_numeric-instance_method)
* [random_ascii](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_ascii-instance_method)
* [random_control](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_control-instance_method)
* [random_hex](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_hex-instance_method)
* [random_lowercase_alpha](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_lowercase_alpha-instance_method)
* [random_lowercase_hex](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_lowercase_hex-instance_method)
* [random_numeric](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_numeric-instance_method)
* [random_octal](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_octal-instance_method)
* [random_printable](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_printable-instance_method)
* [random_punctuation](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_punctuation-instance_method)
* [random_signed_ascii](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_signed_ascii-instance_method)
* [random_symbols](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_symbols-instance_method)
* [random_uppercase_alpha](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_uppercase_alpha-instance_method)
* [random_uppercase_hex](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_uppercase_hex-instance_method)
* [random_visible](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_visible-instance_method)
* [random_whitespace](/docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_whitespace-instance_method)

```ruby
class MetasploitModule < Msf::Exploit::Remote

  def check
    token = rand_text_alphanumeric(8..42)

    # ...
  end

end
```

### Ronin

[Ronin exploits][Ronin::Exploits::Exploit] may include the
[Mixins::Text][Ronin::Exploits::Mixins::Text] module, which adds various
methods such as [random_alpha] or [random_alpha_numeric].

[Ronin::Exploits::Mixins::Text]: /docs/ronin-exploits/Ronin/Exploits/Mixins/Text.html

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/text'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::Text

      def test
        token = random_alpha_numeric(8..42)

        # ...
      end

    end
  end
end
```

### Cheat Sheet

Metasploit                          | Ronin
------------------------------------|------------------------------------------
`rand_text_alpha`                   | [random_alpha]
`rand_text_alphanumeric`            | [random_alpha_numeric]
`rand_text_alpha_lower`             | [random_lowercase_alpha] / `random_lower_alpha`
`rand_text_alpha_upper`             | [random_uppercase_alpha] / `random_upper_alpha`
`rand_text_numeric`                 | [random_numeric] / `random_digits`
`rand_text_hex`                     | [random_hex]
`rand_text_highascii`               | [random_signed_ascii]
`rand_char`                         | [random_ascii] \(without no arguments\)

[random_alpha]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_alpha-instance_method
[random_alpha_numeric]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_alpha_numeric-instance_method
[random_lowercase_alpha]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_lowercase_alpha-instance_method
[random_uppercase_alpha]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_uppercase_alpha-instance_method
[random_numeric]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_numeric-instance_method
[random_hex]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_hex-instance_method
[random_signed_ascii]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_signed_ascii-instance_method
[random_ascii]: /docs/ronin-support/Ronin/Support/Text/Random/Mixin.html#random_asciii-instance_method

## Packing

### Metasploit

Metasploit exploits use Ruby's built-in [Array#pack] method, which packs the
contents of an Array using a binary format String:

[Array#pack]: https://apidock.com/ruby/Array/pack

```ruby
    pop_r3_ret = [0x00013cd0].pack('V')
```

### Ronin

Ronin adds a it's own `pack` method to [Array][ronin-support Array#pack],
[Integer][ronin-support Integer#pack], and [Float][ronin-support Float#pack]
 which can also accept a binary type Symbol name instead of a pack String:

[ronin-support Array#pack]: /docs/ronin-support/Array.html#pack-instance_method
[ronin-support Integer#pack]: /docs/ronin-support/Integer.html#pack-instance_method
[ronin-support Float#pack]: /docs/ronin-support/Float.html#pack-instance_method

```ruby
    pop_r3_ret = 0x00013cd0.pack(:uint32_le)
```

If the [Ronin exploit][Ronin::Exploits::Exploit] includes
[Mixins::Binary][Ronin::Exploits::Mixins::Binary], then a
[pack][Ronin::Exploits::Mixins::Binary#pack] method will be added, which packs
a single value based on the exploit's defined [arch] and [os].

[Ronin::Exploits::Mixins::Binary]: /docs/ronin-exploits/Ronin/Exploits/Mixins/Binary.html
[Ronin::Exploits::Mixins::Binary#pack]: /docs/ronin-exploits/Ronin/Exploits/Mixins/Binary.html#pack-instance_method

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/metadata/arch'
require 'ronin/exploits/metadata/os'
require 'ronin/exploits/mixins/binary'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Metadata::Arch
      include Metadata::OS
      include Mixins::Binary

      arch :x86_64
      os :linux

      def build
        # ...

        buf << pack(:uint32, 0x12345678)

        # ...
      end

    end
  end
end
```

The [pack][Ronin::Exploits::Mixins::Binary#pack] method can also be used with
the [Mixins::HasTargets][Ronin::Exploits::Mixins::HasTargets] module and will
use the `arch` and `os` of the selected target:

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/binary'
require 'ronin/exploits/mixins/has_targets'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::Binary
      include Mixins::HasTargets

      target arch: :x86_64, os: :linux do |target|
        target.ret = 0xffff1234
      end

      target arch: :arm_le, os: :linux do |target|
        target.ret = 0xffff1234
      end

      target arch: :arm_be, os: :linux do |target|
        target.ret = 0xffff1234
      end

      def build
        # ...

        buf << pack(:uint32, target.ret)

        # ...
      end

    end
  end
end
```

### Cheat Sheet

Metasploit                          | Ronin
------------------------------------|------------------------------------------
`[i].pack('C')`                     | `i.pack(:uchar)`
`[i].pack('S')`                     | `i.pack(:uint16)`
`[i].pack('L')`                     | `i.pack(:uint32)`
`[i].pack('Q')`                     | `i.pack(:uint64)`
`[i].pack('c')`                     | `i.pack(:char)`
`[i].pack('s')`                     | `i.pack(:int16)`
`[i].pack('l')`                     | `i.pack(:int32)`
`[i].pack('q')`                     | `i.pack(:int64)`
`[i].pack('S<')`                    | `i.pack(:uint16_le)`
`[i].pack('L<')`                    | `i.pack(:uint32_le)`
`[i].pack('Q<')`                    | `i.pack(:uint64_le)`
`[i].pack('s<')`                    | `i.pack(:int16_le)`
`[i].pack('l<')`                    | `i.pack(:int32_le)`
`[i].pack('q<')`                    | `i.pack(:int64_le)`
`[i].pack('S>')`                    | `i.pack(:uint16_be)`
`[i].pack('L>')`                    | `i.pack(:uint32_be)`
`[i].pack('Q>')`                    | `i.pack(:uint64_be)`
`[i].pack('s>')`                    | `i.pack(:int16_be)`
`[i].pack('l>')`                    | `i.pack(:int32_be)`
`[i].pack('q>')`                    | `i.pack(:int64_be)`
`[f].pack('F')` / `[f].pack('f')`   | `f.pack(:float)` / `f.pack(:float32)`
`[f].pack('D')` / `[f].pack('d')`   | `f.pack(:double)` / `f.pack(:float64)`
`[f].pack('e')`                     | `f.pack(:float_le)` / `f.pack(:float32_le)`
`[f].pack('E')`                     | `f.pack(:double_le)` / `f.pack(:float64_le)`
`[f].pack('g')`                     | `f.pack(:float_be)` / `f.pack(:float32_be)`
`[f].pack('G')`                     | `f.pack(:double_be)` / `f.pack(:float64_be)`
`[i].pack('n')`                     | `i.pack(:uint16_le)`
`[i].pack('N')`                     | `i.pack(:uint32_le)`
`[i].pack('v')`                     | `i.pack(:uint16_be)`
`[i].pack('V')`                     | `i.pack(:uint32_be)`
`[...].pack('VVV')`                 | `[...].pack([:uint32_le, 3])`
`[...].pack('V*')`                  | `[...].pack(:uint32_le..)`
`[...].pack('VS<C')`                | `[...].pack(:uint32_le, :uint16_le, :uchar)`

## Remote TCP

### Metasploit

A Metasploit exploit can connect to a remote TCP service, specified by the
`RHOST`` and `RPORT` options. if it includes `Msf::Exploit::Remote::Tcp`.

```ruby
class MetasploitModule < Msf::Exploit::Remote

  include Msf::Exploit::Remote::Tcp

  def exploit
    begin
      connect
      packet = "..."

      sock.put(packet)

      disconnect
    rescue ::Exception => e
      fail_with(Failure::Unreachable, "Unable to connect")
    end
  end
end
```

### Ronin

A [Ronin exploit][Ronin::Exploits::Exploit] can also connect to a remote TCP
service, specified by the `host` and `port` params, if it includes the
[Ronin::Exploits::Mixins::RemoteTCP] module. The module also adds TCP helper
methods for connecting, sending data, receiving data:

* [tcp_open?](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html#tcp_open%3F-instance_method)
* [tcp_connect](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html#tcp_connect-instance_method)
* [tcp_connect_and_send](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html#tcp_connect_and_send-instance_method)
* [tcp_banner](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html#tcp_banner-instance_method)
* [tcp_send](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteTCP.html#tcp_send-instance_method)

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/remote_tcp'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::RemoteTCP

      def build
        @buffer = "..."
      end

      def launch
        # connect to the remote TCP service, send the data, return the socket
        @socket = tcp_connect_and_send(@buffer)
      end

      def cleanup
        # close the connection
        @socket.close
      end

    end
  end
end
```

### Cheat Sheet

Metasploit                          | Ronin
------------------------------------|------------------------------------------
`include Msf::Exploit::Remote::Tcp` | `include Mixins::RemoteTCP`
`rhost`                             | `host`
`rport`                             | `port`
`peer`                              | `"#{host}:#{port}"`
`connect`                           | `@socket = tcp_connect` / `@socket = tcp_connect_and_send(@buffer)`
`banner = sock.get_once`            | `tcp_banner` / `socket.gets`
`disconnect`                        | `socket.close`

## Remote UDP

### Metasploit

A Metasploit exploit can connect to a remote UDP service, specified by the
`RHOST`` and `RPORT` options. if it includes the `Msf::Exploit::Remote::Udp`
module.

```ruby
class MetasploitModule < Msf::Exploit::Remote

  include Msf::Exploit::Remote::Udp

  def exploit
    connect_udp

    sploit = "..."

    udp_sock.put(sploit)

    handler
    disconnect_udp
  end
end
```

### Ronin

A [Ronin exploit][Ronin::Exploits::Exploit] can also connect to a remote UDP
service, specified by the `host` and `port` params, if it includes the
[Ronin::Exploits::Mixins::RemoteUDP] module. The module also adds UDP helper
methods for connecting, sending data, and receiving data:

* [udp_open?](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html#udp_open%3F-instance_method)
* [udp_connect](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html#udp_connect-instance_method)
* [udp_connect_and_send](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html#udp_connect_and_send-instance_method)
* [udp_banner](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html#udp_banner-instance_method)
* [udp_send](/docs/ronin-exploits/Ronin/Exploits/Mixins/RemoteUDP.html#udp_send-instance_method)

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/remote_udp'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::RemoteUDP

      # ...

      def build
        @buffer = "..."
      end

      def launch
        # connect to the remote UDP service, send the data, return the socket
        @socket = udp_connect_and_send(@buffer)
      end

      def cleanup
        # close the connection
        @socket.close
      end

    end
  end
end
```

### Cheat Sheet

Metasploit                          | Ronin
------------------------------------|-------------------------------------------
`include Msf::Exploit::Remote::Udp` | `include Mixins::RemoteUDP`
`rhost`                             | `host`
`rport`                             | `port`
`connect_udp`                       | `@socket = udp_connect` / `@socket = udp_connect_and_send(@buffer)`
`banner = sock.get_once`            | `udp_banner` / `socket.gets`
`disconnect_udp`                    | `socket.close`

## HTTP

### Metasploit

A Metasploit exploits may send HTTP requests using the `send_request_cgi`
method, if it includes the `Msf::Exploits::Remote::HttpClient` module.

```ruby
    # perform a GET request
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(target_uri.path)
    })

    # ...

    # perform a POST request
    send_request_cgi({
      'method' => 'POST',
      'uri'    => normalize_uri(target_uri.path),
      'data'   => soap
    }, 1)
```

### Ronin

[Ronin exploits][Ronin::Exploits::Exploit] can also send HTTP requests to a
remote web server, specified by the `base_url` param, if it includes
the [Mixins::HTTP][Ronin::Exploits::Mixins::HTTP] module.
The [Mixins::HTTP][Ronin::Exploits::Mixins::HTTP] module will add *many*
`http_` helper methods to the exploit:

* [http_allowed_methods](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_allowed_methods-instance_method)
* [http_cookie](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_cookie-instance_method)
* [http_copy](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_copy-instance_method)
* [http_delete](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_delete-instance_method)
* [http_get](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_get-instance_method)
* [http_get_body](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_get_body-instance_method)
* [http_get_cookies](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_get_cookies-instance_method)
* [http_get_headers](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_get_headers-instance_method)
* [http_head](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_head-instance_method)
* [http_headers](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_headers-instance_method)
* [http_lock](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_lock-instance_method)
* [http_mkcol](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_mkcol-instance_method)
* [http_move](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_move-instance_method)
* [http_ok?](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_ok%3F-instance_method)
* [http_options](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_options-instance_method)
* [http_patch](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_patch-instance_method)
* [http_post](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_post-instance_method)
* [http_post_body](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_post_body-instance_method)
* [http_post_headers](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_post_headers-instance_method)
* [http_powered_by_header](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_powered_by_header-instance_method)
* [http_propfind](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_propfind-instance_method)
* [http_proppatch](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_proppatch-instance_method)
* [http_put](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_put-instance_method)
* [http_request](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_request-instance_method)
* [http_response_body](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_response_body-instance_method)
* [http_response_status](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_response_status-instance_method)
* [http_server_header](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_server_header-instance_method)
* [http_trace](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_trace-instance_method)
* [http_unlock](/docs/ronin-exploits/Ronin/Exploits/Mixins/HTTP.html#http_unlock-instance_method)

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/http'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::HTTP

      param :path, String, required: true,
                           desc:     'The target path to exploit'

      def launch
        # perform a GET request
        response = http_get(params[:path])

        # perform a GET request with query params
        response = http_get(params[:path], query_params: {'foo' => 'bar'})

        # perform a POST request
        response = http_post(params[:path], body: data)

        # perform a POST request with form params
        response = http_post(params[:path], form_data: {'foo' => 'bar'})
      end

    end
  end
end
```

### Cheat Sheet

Metasploit                          | Ronin
------------------------------------|------------------------------------------
`send_request_cgi({'method' => 'DELETE', ...})`  | `http_delete(...)`
`send_request_cgi({'method' => 'HEAD', ...})`    | `http_head(...)`
`send_request_cgi({'method' => 'GET', ...})`     | `http_get(...)`
`send_request_cgi({'method' => 'OPTIONS', ...})` | `http_options(...)`
`send_request_cgi({'method' => 'POST', ...})`    | `http_post(...)`
`send_request_cgi({'method' => 'PUT', ...})`     | `http_put(...)`
`'uri' => '/index.php'` | `'/index.php'`
`'uri' => normalize_uri(target_uri.path), ...}` | `path`
`'headers' => {...}` | `headers: {...}`
`'authorization' => "..."` | `authorization: "..."`
`'authorization' => basic_auth(user,pass)` | `user: user, password: pass`
`'data' => ...` | `body: ...`
`'cookie' => ...` | `cookie: ...`
`'ctype' => ...` | `content_type: ...`
`'vars_get' => {...}`  | `query_params: {...}`
`'vars_post' => {...}` | `form_data: {...}`

## Loot

### Metasploit

A Metasploit exploit can store captured files or other data from a compromised
system using the `store_loot` method:

```ruby
loot_path = store_loot('gitlab.secrets', 'text/plain', datastore['RHOST'], secrets_yml, 'secrets.yml')
```

JSON, YAML, and CSV data can also be stored:

```ruby
stored_path = store_loot('ad.exchange.mailboxes', 'text/csv', rhost, mailbox_table.to_csv)
```

### Ronin

[Ronin exploits][Ronin::Exploits::Exploit] can store captured files or other
data from a compromised system by including
[Mixins::Loot][Ronin::Exploits::Mixins::Loot] and calling the [loot.add_file]
method:

[Ronin::Exploits::Mixins::Loot]: /docs/ronin-exploits/Ronin/Exploits/Mixins/Loot.html
[loot.add_file]: /docs/ronin-exploits/Ronin/Exploits/Loot.html#add-instance_method

```ruby
require 'ronin/exploits/exploit'
require 'ronin/exploits/mixins/loot'

module Ronin
  module Exploits
    class MyExploit < Exploit

      include Mixins::Loot

      def launch
        # ...

        loot.add_file('foo.txt', captured_data1)
        loot.add_file('dir/bar.txt', captured_data2)
      end

    end
  end
end
```

JSON, YAML, and CSV data can also be automatically serialized and stored:

```ruby
loot.add('foo.json', captured_data, format: :json)

loot.add('foo.yaml', captured_data, format: :yaml)

loot.add('foo.csv',  captured_data, format: :csv)
```

### Cheat Sheet

Metasploit                                        | Ronin
--------------------------------------------------|-----------------------------
`store_file('foo.bar', 'mime/type', rhost, data)` | `loot.add('foo/bar.txt',data)`

[ronin-exploits]: /docs/ronin-exploits/
[Ronin::Exploits::Exploit]: /docs/ronin-exploits/Ronin/Exploits/Exploit.html
